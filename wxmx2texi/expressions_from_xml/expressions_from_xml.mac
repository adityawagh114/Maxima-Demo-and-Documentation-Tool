/* expressions_from_xml.mac -- process Maxima expressions constructed from wxmx output XML
 *
 * Note that these pattern matching rules work only for
 * expressions created from wxMaxima wxmx <output> XML tags.
 * The goal is to construct a list of tokens which can then
 * be reassembled into the Maxima expression represented by
 * the wxmx output XML.
 *
 * copyright 2021 by Robert Dodier
 * I release this work under terms of the GNU General Public License
 */

load ("expressions_from_xml.lisp");

matchdeclare ([aa, bb], all);

defrule (rule_for_numbers, n()(aa), parse_string(aa));
defrule (rule_for_variables, v()(aa), ?makealias(aa));
defrule (rule_for_greek_variables, g()(aa), ?makealias(aa));
defrule (rule_for_hidden_ops, h()(aa), ?makealias(aa));
defrule (rule_for_function_names, fnm()(aa), ?makealias(aa));
defrule (rule_for_functions, fn()(aa, bb), [aa, bb]);

paren_left: ?makealias("(");
paren_right: ?makealias (")");

forward_slash: ?makealias("/");
defrule (rule_for_fractions, f()(aa, bb), [paren_left, aa, paren_right, forward_slash, paren_left, bb, paren_right]);

caret: ?makealias("^");
defrule (rule_for_exponents, e()(aa, bb), [paren_left, aa, paren_right, caret, paren_left, bb, paren_right]);

defrule (rule_for_text, t()(aa), ?makealias(aa));

matchdeclare (rr, lambda ([e], not atom(e) and op(e) = r()));
defrule (rule_for_rows, rr, args(rr));

matchdeclare (pp, lambda ([e], not atom(e) and op(e) = p()));
defrule (rule_for_parentheses, pp, [paren_left, args(pp), paren_right]);

tokens_from (e%) :=
  apply1 (e%, rule_for_numbers,
              rule_for_variables,
              rule_for_greek_variables,
              rule_for_hidden_ops,
              rule_for_function_names,
              rule_for_functions,
              rule_for_fractions,
              rule_for_exponents,
              rule_for_text,
              rule_for_rows,
              rule_for_parentheses);
